// Generated by CoffeeScript 1.10.0
(function() {
  var ArrayType, CharArray, Iconv, UFCRequestQueue, UFCoder, co, ffi, jsonminify, libname, ref, uFCoderLib;

  ffi = require('ffi');

  ref = require('ref');

  ArrayType = require('ref-array');

  co = require('co');

  jsonminify = require("jsonminify");

  Iconv = require('iconv').Iconv;

  libname = 'libuFCoder-x86';

  if (process.arch === 'x64') {
    libname += '_64';
  }

  CharArray = ArrayType(ref.types.char);

  uFCoderLib = new ffi.Library(__dirname + "/lib/" + libname, {
    "ReaderOpen": ["int", []],
    "GetReaderType": ["int", [ref.refType('uint32')]],
    "GetCardId": ["int", [ref.refType('uint8'), ref.refType('uint32')]],
    "ReaderUISignal": ["int", ['int', 'int']],

    /*
    uint8_t *aucData,
    uint16_t usLinearAddress,
    uint16_t usDataLength,
    uint16_t *lpusBytesReturned,
    uint8_t ucKeyMode,
    uint8_t ucReaderKeyIndex
     */
    "LinearRead": ["int", [CharArray, 'int', 'int', ref.refType('uint16'), 'int', 'int']],

    /*
    uint8_t *aucData,
    uint16_t usLinearAddress,
    uint16_t usDataLength,
    uint16_t *lpusBytesWritten,
    uint8_t ucKeyMode,
    uint8_t ucReaderKeyIndex
     */
    "LinearWrite": ["int", [CharArray, 'int', 'int', ref.refType('uint16'), 'int', 'int']]
  });

  UFCRequestQueue = (function() {
    function UFCRequestQueue() {
      this.queue = [];
      this.inProgress = false;
    }

    UFCRequestQueue.prototype.add = function(uFCoderLibFunction, params) {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          var request;
          request = {
            fce: uFCoderLibFunction,
            params: params,
            resolve: resolve,
            reject: reject
          };
          _this.queue.push(request);
          return _this.process();
        };
      })(this));
    };

    UFCRequestQueue.prototype.process = function() {
      var request;
      if (!this.inProgress && this.queue.length > 0) {
        this.inProgress = true;
        request = this.queue.shift();
        request.params.push((function(_this) {
          return function(error, result) {
            _this.inProgress = false;
            _this.process();
            if (error) {
              return request.reject(error);
            }
            return request.resolve(result);
          };
        })(this));
        return request.fce.async.apply(this, request.params);
      }
    };

    return UFCRequestQueue;

  })();

  UFCoder = (function() {
    function UFCoder(io) {
      this.io = io;
      this.uFCRequestQueue = new UFCRequestQueue();
      this.cardSnaped = false;
      co(this.detectCard());
    }

    UFCoder.prototype.detectCard = function*() {
      var card, data, error, error1, error2;
      try {
        card = (yield this.getCardId());
        if (!this.cardSnaped) {
          data = {
            card: {
              type: card.cardType,
              serial: card.cardSerial
            }
          };
          data.data = {
            JSONraw: (yield this.linearRead())
          };
          try {
            data.data.JSON = JSON.parse(data.data.JSONraw);
          } catch (error1) {
            error = error1;
            console.log(error);
          }
          this.io.emit('card', data);
          (yield this.uFCRequestQueue.add(uFCoderLib.ReaderUISignal, [0, 1]));
          console.log(data);
        }
        return this.cardSnaped = true;
      } catch (error2) {
        error = error2;
        return this.cardSnaped = false;
      } finally {
        (yield (function(callback) {
          return setTimeout(callback, 500);
        }));
        co(this.detectCard());
      }
    };

    UFCoder.prototype.checkStatus = function*(status) {
      if (status === 161) {
        (yield (this.uFCRequestQueue.add(uFCoderLib.ReaderOpen, [])));
      }
      if (status !== 0) {
        throw new Error("uFCoder status " + status);
      }
      return;
    };

    UFCoder.prototype.readerOpen = function*() {
      var status;
      status = (yield (this.uFCRequestQueue.add(uFCoderLib.ReaderOpen, [])));
      (yield this.checkStatus(status));
      return status;
    };

    UFCoder.prototype.getReaderType = function*() {
      var readerType, status;
      readerType = ref.alloc('uint32');
      status = (yield (this.uFCRequestQueue.add(uFCoderLib.GetReaderType, [readerType])));
      (yield this.checkStatus(status));
      return readerType.deref();
    };

    UFCoder.prototype.getCardId = function*() {
      var cardSerial, cardType, status;
      cardType = ref.alloc('uint8');
      cardSerial = ref.alloc('uint32');
      status = (yield (this.uFCRequestQueue.add(uFCoderLib.GetCardId, [cardType, cardSerial])));
      (yield this.checkStatus(status));
      return {
        cardType: cardType.deref(),
        cardSerial: cardSerial.deref()
      };
    };

    UFCoder.prototype.readerUISignal = function*(light, sound) {
      var status;
      status = (yield (this.uFCRequestQueue.add(uFCoderLib.ReaderUISignal, [light, sound])));
      (yield this.checkStatus(status));
      return status;
    };

    UFCoder.prototype.linearRead = function*() {
      var aucData, data, error, error1, i, j, lpusBytesReturned, ref1, status;
      aucData = new CharArray(752);
      lpusBytesReturned = ref.alloc('uint16');
      status = (yield (this.uFCRequestQueue.add(uFCoderLib.LinearRead, [aucData, 0, aucData.length, lpusBytesReturned, 96, 0])));
      data = '';
      for (i = j = 0, ref1 = lpusBytesReturned.deref() - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j) {
        if (aucData[i] === 0) {
          break;
        }
        try {
          data += String.fromCharCode(aucData[i]);
        } catch (error1) {
          error = error1;
          console.log(error);
          break;
        }
      }
      (yield this.checkStatus(status));
      return data;
    };

    UFCoder.prototype.linearWrite = function*(data) {
      var aucData, char, iconv, j, k, key, len, lpusBytesReturned, ref1, status;
      data = jsonminify(data);
      iconv = new Iconv('UTF-8', 'ASCII//TRANSLIT//IGNORE');
      data = iconv.convert(data);
      aucData = new CharArray(752);
      for (key = j = 0, ref1 = aucData.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; key = 0 <= ref1 ? ++j : --j) {
        aucData[key] = "";
      }
      for (key = k = 0, len = data.length; k < len; key = ++k) {
        char = data[key];
        aucData[key] = char;
      }
      lpusBytesReturned = ref.alloc('uint16');
      status = (yield (this.uFCRequestQueue.add(uFCoderLib.LinearWrite, [aucData, 0, aucData.length, lpusBytesReturned, 96, 0])));
      (yield this.checkStatus(status));
      return {
        data: data,
        written: lpusBytesReturned.deref()
      };
    };

    return UFCoder;

  })();

  module.exports = UFCoder;


  /*
  readerType = ref.alloc('uint32')
  console.log uFCoder.ReaderOpen()
  console.log uFCoder.GetReaderType(readerType)
  console.log readerType.deref()
   */

}).call(this);
